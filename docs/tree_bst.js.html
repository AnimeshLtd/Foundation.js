

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      tree/bst.js - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  
  <link type="text/css" rel="stylesheet" href="styles/collapse.css">
  

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      Foundation.js Reference
    </h3>

    
      <h3>
        Resources
      </h3>
      
        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide">JS Guide (Mozilla)</a>
      
    

    <h3>Classes</h3><ul><li id="BinarySearchTree-nav"><a href="BinarySearchTree.html">BinarySearchTree</a><ul class='methods'><li data-type="method" id="BinarySearchTree-add-nav"><a href="BinarySearchTree.html#add">add</a></li><li data-type="method" id="BinarySearchTree-find-nav"><a href="BinarySearchTree.html#find">find</a></li><li data-type="method" id="BinarySearchTree-remove-nav"><a href="BinarySearchTree.html#remove">remove</a></li><li data-type="method" id="BinarySearchTree-toString-nav"><a href="BinarySearchTree.html#toString">toString</a></li></ul></li><li id="BinaryTreeNode-nav"><a href="BinaryTreeNode.html">BinaryTreeNode</a><ul class='methods'><li data-type="method" id="BinaryTreeNode-toJSON-nav"><a href="BinaryTreeNode.html#toJSON">toJSON</a></li></ul></li><li id="List-nav"><a href="List.html">List</a><ul class='methods'><li data-type="method" id="List-add-nav"><a href="List.html#add">add</a></li><li data-type="method" id="List-find-nav"><a href="List.html#find">find</a></li><li data-type="method" id="List-indexOf-nav"><a href="List.html#indexOf">indexOf</a></li><li data-type="method" id="List-itemAtIndex-nav"><a href="List.html#itemAtIndex">itemAtIndex</a></li><li data-type="method" id="List-remove-nav"><a href="List.html#remove">remove</a></li></ul></li><li id="Node-nav"><a href="Node.html">Node</a></li><li id="OutOfBoundsError-nav"><a href="OutOfBoundsError.html">OutOfBoundsError</a></li><li id="Queue-nav"><a href="Queue.html">Queue</a><ul class='methods'><li data-type="method" id="Queue-dequeue-nav"><a href="Queue.html#dequeue">dequeue</a></li><li data-type="method" id="Queue-enqueue-nav"><a href="Queue.html#enqueue">enqueue</a></li></ul></li><li id="Stack-nav"><a href="Stack.html">Stack</a><ul class='methods'><li data-type="method" id="Stack-pop-nav"><a href="Stack.html#pop">pop</a></li><li data-type="method" id="Stack-push-nav"><a href="Stack.html#push">push</a></li></ul></li><li id="TreeNode-nav"><a href="TreeNode.html">TreeNode</a></li></ul><h3>Modules</h3><ul><li id="algorithms-nav"><a href="module-algorithms.html">algorithms</a></li><li id="collections-nav"><a href="module-collections.html">collections</a></li><li id="errors-nav"><a href="module-errors.html">errors</a></li><li id="trees-nav"><a href="module-trees.html">trees</a></li></ul>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        tree/bst.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>const BinaryTreeNode = require("./bstNode")

/**
 *  Binary Search Tree is a specialised binary tree where the children
 *  are ordered such that the left child's value has to be less than or
 *  equal to that of the parent, and the right child must be larger than
 *  the parent.
 * 
 *  left child ≤ parent node ≤ right child
 * 
 *  All binary search trees must have a root node. Nodes may need re-ordering
 *  after each insert/delete operation to keep the left-parent-right constraint.
 * 
 *  **The data stored in BinarySearchTree must support comparison operations such**
 *  **as `&lt;`, `>`, `==` in a coherent manner.** Failing to ensure this will result 
 *  in undefined behaviour.
 * 
 *  @class
 */
class BinarySearchTree {
  constructor() {
    this._root = null
    this._count = 0 
  }

  /**
   *  Get the total number of nodes in the tree. May **not** be same as the depth or
   *  height of the tree.
   */
  get count() {
    return this._count
  }

  /**
   *  Returns the node having the "smallest" value of data in the entire tree.
   *  @returns {BinaryTreeNode} smallest node
   */
  get min() {
    return this.getLeftmost()
  }

  /**
   *  Returns the node having the "largest" value of data in the entire tree.
   *  @returns {BinaryTreeNode} largest node
   */
  get max() {
    return this.getRightmost()
  }

  /**
   *  Returns a JSON string representation of the tree.
   *  @returns {string}
   */
  toString() {
    return JSON.stringify({
      count: this._count,
      nodes: this._root.toJSON()
    })
  }

  /**
   *  Inserts the a new node into the tree and attachs the given `data` to it.  
   *  `data` must be a type which supports logical operations of `==`, `&lt;=`, `>=`.
   * 
   *  - If the tree is empty, the newly created node is added as root.
   *  - If the `data` is already in a tree node (== equality), simply increments the `copies` 
   *    value of that {@link BinaryTreeNode} (`node.metadata.copies`).
   * 
   *  Returns the newly added node.
   *   
   *  @param {any} data 
   *  @returns {BinaryTreeNode} newly added node.
   */
  add(data) {
    const newNode = new BinaryTreeNode(data)

    if (!this._root) {
      this._root = newNode
      this._count += 1
      return newNode
    }

    const { node, parent } = this.findNode(data)
    if (node) {
      node.metadata.copies += 1
    }
    else if (data &lt; parent.data) {
      parent.leftChild = (newNode)
    }
    else {
      parent.rightChild = (newNode)
    }

    this._count += 1
    return newNode
  }

  /**
   *  Returns the tree node containing `data` (== equality) or `null` if none.
   *  
   *  @param {BinaryTreeNode} data
   *  @returns {?BinaryTreeNode}
   */
  find(data) {
    return this.findNode(data).node
  }

  /**
   *  Recursively finds the node matching the `data` (== equality)। If no match 
   *  is found, returns the `parent` to which a new node with this `data` must 
   *  be attached.
   * 
   *  Returns object of the form: `{ node: BinaryTreeNode | null, parent: BinaryTreeNode}`
   *  
   *  @private
   *  @param {any} data
   *  @param {BinaryTreeNode} node node to search from; default is root
   *  @param {BinaryTreeNode} parent used to keep track of parent (set when recursing)
   *  @returns {object}
   */
  findNode(data, node = this._root, parent = null) {
    if (!node || node.data == data) {
      return { node, parent }
    }

    if (data &lt; node.data) {
      return this.findNode(data, node.leftChild, node)
    }

    return this.findNode(data, node.rightChild, node)
  }

  /**
   *  Removes the node having `data` if it's the only copy left (`node.metadata.copies` is 1).
   *  To delete some copies of `data` in the node, simply set `copies` param to
   *  a numeric value. If this value is more than `node.metadata.copies` than the
   *  node is removed from the tree.
   *  
   *  **By default, deletes all copies of `data` in the node and removes node from the tree.**
   *  If the removed node had children, they are assigned new parent 
   *  node(s).
   *  
   *  If no node is found, returns `null`. Otherwise, returns the removed/modified node.
   * 
   *  @param {any} data
   *  @param {number} copies number of copies to delete; deletes all by default
   *  @returns {?BinaryTreeNode} node
   */
  remove(data, copies = '*') {
    const { node, parent } = this.findNode(data)
    if (!node) { return null }

    // Update node metadata and check if the node needs to be actually 
    // removed.
    if (copies === '*') {
      // the '- 1' here accounts for the this._count -= 1 line at the
      // end of the function, which is triggered only if the node is
      // actually removed.
      this._count -= node.metadata.copies - 1
      node.metadata.copies = 0
    }
    else {
      this._count -= (copies >= node.metadata.copies) ? node.metadata.copies - 1 : copies 
      node.metadata.copies -= copies
    }

    if (node.metadata.copies >= 1) {
      // Nothing needs to deleted, some copies remain
      return node
    }

    // Only 1 or fewer copies remain. Node must be removed from the tree.
    const heir = this.makeSubtreeWithoutParent(node)
    if (node === this._root) {
      // Set the remaining subtree as the root and clear reference
      // to the old parent
      this._root = heir
      if (this._root) { this._root.parent = null }
    }
    else if (node.isLeftChild) {
      parent.leftChild = heir
    }
    else {
      parent.rightChild = heir
    }

    this._count -= 1
    return node
  }

  /**
   *  Removes the given parent node and combines the newly orphaned left and
   *  right branches into a new subtree. Returns the root of this new subtree.
   *  
   *      30*                             40
   *    /     \                          /  \
   *   10      40      combined        35   50
   *     \    /  \    ---------->     /
   *     15  35   50                 10
   *                                   \
   *                                    15
   *
   *  Node to be removed is 30. It takes node 30 left subtree (10 and 15) and 
   *  put it in the leftmost node of the right subtree (40, 35, 50).
   * 
   *  @private
   *  @param {BinaryTreeNode} parent parent to be removed
   *  @returns {BinaryTreeNode} parent of the new subtree
   */
  makeSubtreeWithoutParent(parent) {
    if (parent.rightChild) {
      const leftmost = this.getLeftmost(parent.rightChild)
      leftmost.leftChild = parent.leftChild
      return parent.rightChild
    }
    return parent.leftChild
  }

  /** @private */
  getRightmost(node = this._root) {
    if (!node || !node.right) {
      return node
    }
    return this.getRightmost(node.right)
  }

  /** @private */
  getLeftmost(node = this._root) {
    if (!node || !node.left) {
      return node
    }
    return this.getLeftmost(node.left)
  }
}

module.exports = BinarySearchTree
</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  

</body>
</html>

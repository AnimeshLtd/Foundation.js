

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      trees/bst.js - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  
  <link type="text/css" rel="stylesheet" href="styles/collapse.css">
  

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      Foundation.js Reference
    </h3>

    
      <h3>
        Resources
      </h3>
      
        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide">JS Guide (Mozilla)</a>
      
    

    <h3>Classes</h3><ul><li id="BinarySearchTree-nav"><a href="BinarySearchTree.html">BinarySearchTree</a><ul class='methods'><li data-type="method" id="BinarySearchTree-add-nav"><a href="BinarySearchTree.html#add">add</a></li><li data-type="method" id="BinarySearchTree-find-nav"><a href="BinarySearchTree.html#find">find</a></li><li data-type="method" id="BinarySearchTree-remove-nav"><a href="BinarySearchTree.html#remove">remove</a></li><li data-type="method" id="BinarySearchTree-searchBreadthFirst-nav"><a href="BinarySearchTree.html#searchBreadthFirst">searchBreadthFirst</a></li><li data-type="method" id="BinarySearchTree-searchDepthFirst-nav"><a href="BinarySearchTree.html#searchDepthFirst">searchDepthFirst</a></li><li data-type="method" id="BinarySearchTree-toString-nav"><a href="BinarySearchTree.html#toString">toString</a></li><li data-type="method" id="BinarySearchTree-traverseInOrderly-nav"><a href="BinarySearchTree.html#traverseInOrderly">traverseInOrderly</a></li><li data-type="method" id="BinarySearchTree-traversePostOrderly-nav"><a href="BinarySearchTree.html#traversePostOrderly">traversePostOrderly</a></li><li data-type="method" id="BinarySearchTree-traversePreOrderly-nav"><a href="BinarySearchTree.html#traversePreOrderly">traversePreOrderly</a></li></ul></li><li id="BinaryTreeNode-nav"><a href="BinaryTreeNode.html">BinaryTreeNode</a><ul class='methods'><li data-type="method" id="BinaryTreeNode-toJSON-nav"><a href="BinaryTreeNode.html#toJSON">toJSON</a></li></ul></li><li id="HashMap-nav"><a href="HashMap.html">HashMap</a><ul class='methods'><li data-type="method" id="HashMap-add-nav"><a href="HashMap.html#add">add</a></li><li data-type="method" id="HashMap-delete-nav"><a href="HashMap.html#delete">delete</a></li><li data-type="method" id="HashMap-get-nav"><a href="HashMap.html#get">get</a></li><li data-type="method" id="HashMap-has-nav"><a href="HashMap.html#has">has</a></li></ul></li><li id="List-nav"><a href="List.html">List</a><ul class='methods'><li data-type="method" id="List-add-nav"><a href="List.html#add">add</a></li><li data-type="method" id="List-find-nav"><a href="List.html#find">find</a></li><li data-type="method" id="List-indexOf-nav"><a href="List.html#indexOf">indexOf</a></li><li data-type="method" id="List-itemAtIndex-nav"><a href="List.html#itemAtIndex">itemAtIndex</a></li><li data-type="method" id="List-remove-nav"><a href="List.html#remove">remove</a></li></ul></li><li id="Node-nav"><a href="Node.html">Node</a></li><li id="OutOfBoundsError-nav"><a href="OutOfBoundsError.html">OutOfBoundsError</a></li><li id="Queue-nav"><a href="Queue.html">Queue</a><ul class='methods'><li data-type="method" id="Queue-dequeue-nav"><a href="Queue.html#dequeue">dequeue</a></li><li data-type="method" id="Queue-enqueue-nav"><a href="Queue.html#enqueue">enqueue</a></li></ul></li><li id="Stack-nav"><a href="Stack.html">Stack</a><ul class='methods'><li data-type="method" id="Stack-pop-nav"><a href="Stack.html#pop">pop</a></li><li data-type="method" id="Stack-push-nav"><a href="Stack.html#push">push</a></li></ul></li><li id="TreeMap-nav"><a href="TreeMap.html">TreeMap</a><ul class='methods'><li data-type="method" id="TreeMap-add-nav"><a href="TreeMap.html#add">add</a></li><li data-type="method" id="TreeMap-delete-nav"><a href="TreeMap.html#delete">delete</a></li><li data-type="method" id="TreeMap-get-nav"><a href="TreeMap.html#get">get</a></li><li data-type="method" id="TreeMap-has-nav"><a href="TreeMap.html#has">has</a></li><li data-type="method" id="TreeMap-keys-nav"><a href="TreeMap.html#keys">keys</a></li><li data-type="method" id="TreeMap-values-nav"><a href="TreeMap.html#values">values</a></li></ul></li></ul><h3>Modules</h3><ul><li id="algorithms-nav"><a href="module-algorithms.html">algorithms</a></li><li id="errors-nav"><a href="module-errors.html">errors</a></li><li id="linear-nav"><a href="module-linear.html">linear</a></li><li id="maps-nav"><a href="module-maps.html">maps</a></li><li id="trees-nav"><a href="module-trees.html">trees</a></li></ul>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        trees/bst.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>const BinaryTreeNode = require("./bstNode")
const Queue = require("../linear").Queue
const Stack = require("../linear").Stack

/**
 *  Binary Search Tree is a specialised binary tree where the children
 *  are ordered such that the left child's value has to be less than or
 *  equal to that of the parent, and the right child must be larger than
 *  the parent.
 * 
 *  left child ≤ parent node ≤ right child
 * 
 *  All binary search trees must have a root node. Nodes may need re-ordering
 *  after each insert/delete operation to keep the left-parent-right constraint.
 * 
 *  **The data stored in BinarySearchTree must support comparison operations such**
 *  **as `&lt;`, `>`, `==` in a coherent manner.** Failing to ensure this will result 
 *  in undefined behaviour.
 * 
 *  @class
 */
class BinarySearchTree {
  constructor() {
    this._root = null
    this._count = 0 
  }

  /**
   *  Get the total number of nodes in the tree. May **not** be same as the depth or
   *  height of the tree.
   */
  get count() {
    return this._count
  }

  /**
   *  Returns the node having the "smallest" value of data in the entire tree.
   *  @returns {BinaryTreeNode} smallest node
   */
  get min() {
    return this.getLeftmost().data
  }

  /**
   *  Returns the node having the "largest" value of data in the entire tree.
   *  @returns {BinaryTreeNode} largest node
   */
  get max() {
    return this.getRightmost().data
  }

  /**
   *  Returns a JSON string representation of the tree.
   *  @returns {string}
   */
  toString() {
    return JSON.stringify({
      count: this._count,
      nodes: this._root.toJSON()
    })
  }

  /**
   *  Inserts the a new node into the tree and attachs the given `data` to it.  
   *  `data` must be a type which supports logical operations of `==`, `&lt;=`, `>=`.
   * 
   *  - If the tree is empty, the newly created node is added as root.
   *  - If the `data` is already in a tree node (== equality), simply increments the `copies` 
   *    value of that {@link BinaryTreeNode} (`node.metadata.copies`).
   * 
   *  Returns the newly added node.
   *   
   *  @param {any} data 
   *  @returns {BinaryTreeNode} newly added node.
   */
  add(data) {
    const newNode = new BinaryTreeNode(data)

    if (!this._root) {
      this._root = newNode
      this._count += 1
      return newNode
    }

    const { node, parent } = this.findNode(data)
    if (node) {
      node.metadata.copies += 1
    }
    else if (data &lt; parent.data) {
      parent.leftChild = newNode
      newNode._parentSide = "left"
    }
    else {
      parent.rightChild = newNode
      newNode._parentSide = "right"
    }

    this._count += 1
    return newNode
  }

  /**
   *  Returns the tree node containing `data` (== equality) or `null` if none.
   *  
   *  @param {BinaryTreeNode} data
   *  @returns {?BinaryTreeNode}
   */
  find(data) {
    return this.findNode(data).node
  }

  /**
   *  Recursively finds the node matching the `data` (== equality)। If no match 
   *  is found, returns the `parent` to which a new node with this `data` must 
   *  be attached.
   * 
   *  Returns object of the form: `{ node: BinaryTreeNode | null, parent: BinaryTreeNode}`
   *  
   *  @private
   *  @param {any} data
   *  @param {BinaryTreeNode} node node to search from; default is root
   *  @param {BinaryTreeNode} parent used to keep track of parent (set when recursing)
   *  @returns {object}
   */
  findNode(data, node = this._root, parent = null) {
    if (!node || node.data == data) {
      return { node, parent }
    }

    if (data &lt; node.data) {
      return this.findNode(data, node.leftChild, node)
    }

    return this.findNode(data, node.rightChild, node)
  }

  /**
   *  Removes the node having `data` if it's the only copy left (`node.metadata.copies` is 1).
   *  To delete some copies of `data` in the node, simply set `copies` param to
   *  a numeric value. If this value is more than `node.metadata.copies` than the
   *  node is removed from the tree.
   *  
   *  **By default, deletes all copies of `data` in the node and removes node from the tree.**
   *  If the removed node had children, they are assigned new parent 
   *  node(s).
   *  
   *  If no node is found, returns `null`. Otherwise, returns the removed/modified node.
   * 
   *  @param {any} data
   *  @param {number} copies number of copies to delete; deletes all by default
   *  @returns {?BinaryTreeNode} node
   */
  remove(data, copies = '*') {
    const { node, parent } = this.findNode(data)
    if (!node) { return null }

    // Update node metadata and check if the node needs to be actually 
    // removed.
    if (copies === '*') {
      // the '- 1' here accounts for the this._count -= 1 line at the
      // end of the function, which is triggered only if the node is
      // actually removed.
      this._count -= node.metadata.copies - 1
      node.metadata.copies = 0
    }
    else {
      this._count -= (copies >= node.metadata.copies) ? node.metadata.copies - 1 : copies 
      node.metadata.copies -= copies
    }

    if (node.metadata.copies >= 1) {
      // Nothing needs to deleted, some copies remain
      return node
    }

    // Only 1 or fewer copies remain. Node must be removed from the tree.
    const heir = this.makeSubtreeWithoutParent(node)
    if (node === this._root) {
      // Set the remaining subtree as the root and clear reference
      // to the old parent
      this._root = heir
      if (this._root) { this._root.parent = null }
    }
    else if (node.isLeftChild) {
      parent.leftChild = heir
      if (heir) {
        heir._parentSide = "left"
      }
    }
    else {
      parent.rightChild = heir
      if (heir) {
        heir._parentSide = "right"
      }
    }

    this._count -= 1
    return node
  }

  /**
   *  Removes the given parent node and combines the newly orphaned left and
   *  right branches into a new subtree. Returns the root of this new subtree.
   *  
   *      30*                             40
   *    /     \                          /  \
   *   10      40      combined        35   50
   *     \    /  \    ---------->     /
   *     15  35   50                 10
   *                                   \
   *                                    15
   *
   *  Node to be removed is 30. It takes node 30 left subtree (10 and 15) and 
   *  put it in the leftmost node of the right subtree (40, 35, 50).
   * 
   *  @private
   *  @param {BinaryTreeNode} parent parent to be removed
   *  @returns {BinaryTreeNode} parent of the new subtree
   */
  makeSubtreeWithoutParent(parent) {
    if (parent.rightChild) {
      const leftmost = this.getLeftmost(parent.rightChild)
      leftmost.leftChild = parent.leftChild
      if (parent.leftChild) {
        parent.leftChild._parentSide = "left"
      }
      return parent.rightChild
    }
    return parent.leftChild
  }

  /**
   *  Breadth-first searches the tree level by level starting at the root. It visits
   *  the root, then the children of the root, then their children and so on. So for
   *  a tree of shape:
   *  ```
   *         10
   *        /  \
   *      5    30
   *     /    /  \
   *    4    15   40
   *   /
   *  3
   *  ```
   *  Breadth-first traversal would look like: 10, 5, 30, 4, 15, 40, 3
   * 
   *  **Use breadth-first search when the node you are looking for is likely to be**
   *  **nearby the root.**
   *  
   *  @yields {BinaryTreeNode}
   */
  * searchBreadthFirst() {
    const queue = new Queue()
    queue.enqueue(this._root)

    while(queue.length > 0) {
      const node = queue.dequeue()
      yield node
      if (node.leftChild) {
        queue.enqueue(node.leftChild)
      }
      if (node.rightChild) {
        queue.enqueue(node.rightChild)
      }
    }
  }

  /**
   *  Depth-first search starts from the root and goes as deep as it can
   *  until it finds a leaf node. Then it visits all the remaining nodes
   *  it encountered along the path, going as deep as possible in each
   *  branch.
   * 
   *  For a tree of shape:
   *  ```
   *         10
   *        /  \
   *      5    30
   *     /    /  \
   *    4    15   40
   *   /
   *  3
   *  ```
   *  Depth-first traversal would look like:
   *  - In-order (left-root-right) -> 3, 4, 5, 10, 15, 30, 40
   *    see [traverseInOrderly]{@link BinarySearchTree#traverseInOrderly}
   *  - Pre-order (root-left-right) -> 10, 5, 4, 3, 30, 15, 40
   *    see [traversePreOrderly]{@link BinarySearchTree#traversePreOrderly}
   *  - Post-order (left-right-root) -> 3, 4, 5, 15, 40, 30, 10
   *    see [traversePostOrderly]{@link BinarySearchTree#traversePostOrderly}
   *  
   *  This function returns result similar to a pre-order traversal but uses a 
   *  [Stack]{@link Stack} to achieve that. 
   * 
   *  **Use depth-first search when the node you are looking for is likely**
   *  **to be far from the root.**
   *  
   *  @yields {BinaryTreeNode}
   */
  * searchDepthFirst() {
    const stack = new Stack()
    stack.push(this._root)

    while (stack.depth > 0) {
      const node = stack.pop()
      yield node

      if (node.rightChild) {
        stack.push(node.rightChild)
      }
      if (node.leftChild) {
        stack.push(node.leftChild)
      }
    }
  }

  /**
   *  For a binary tree, an in-order traversal returns values sorted in ascending
   *  order.
   *  
   *  @param {BinaryTreeNode} node
   *  @yields {BinaryTreeNode}
   */
  * traverseInOrderly(node = this._root) {
    if (node &amp;&amp; node.leftChild) {
      yield* this.traverseInOrderly(node.leftChild)
    }
    yield node
    if (node &amp;&amp; node.rightChild) {
      yield* this.traverseInOrderly(node.rightChild)
    }
  }

  /**
   *  For a binary tree, a pre-order traversal creates a copy of the tree. If the
   *  tree is used as an expression tree, a pre-order traversal will yield a prefix
   *  expression of the tree (as used in the [Polish notation](https://en.wikipedia.org/wiki/Polish_notation)).
   * 
   *  @param {BinaryTreeNode} node 
   *  @yields {BinaryTreeNode}
   */
  * traversePreOrderly(node = this._root) {
    yield node
    
    if (node.leftChild) {
      yield* this.traversePreOrderly(node.leftChild)
    }
    if (node.rightChild) {
      yield* this.traversePreOrderly(node.rightChild)
    }
  }

  /**
   *  Post-order traversal is used to:
   *  - delete the tree because it visits the children before removing
   *    the parent
   *  - get the postfix expression of an expression tree, as in the reverse
   *    Polish notation
   * 
   *  @param {BinaryTreeNode} node
   *  @yields {BinaryTreeNode} 
   */
  * traversePostOrderly(node = this._root) {
    if (node.leftChild) {
      yield* this.traversePostOrderly(node.leftChild)
    }
    if (node.rightChild) {
      yield* this.traversePostOrderly(node.rightChild)
    }
    yield node
  }

  /** @private */
  getRightmost(node = this._root) {
    if (!node || !node.rightChild) {
      return node
    }
    return this.getRightmost(node.rightChild)
  }

  /** @private */
  getLeftmost(node = this._root) {
    if (!node || !node.leftChild) {

      return node
    }
    return this.getLeftmost(node.leftChild)
  }
}

module.exports = BinarySearchTree
</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  

</body>
</html>
